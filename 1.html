<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Class: [Topic Title]</title> <!-- Replace [Topic Title] with e.g., Introduction -->
    <link rel="stylesheet" href="css/styles.css">
    <style>
        #video-intro-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #intro-video {
            display: none;
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
        }

        #pixel-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .main-content {
            opacity: 0;
            transition: opacity 1.5s ease-in;
        }

        .main-content.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Video Intro Container -->
    <div id="video-intro-container">
        <video id="intro-video" muted playsinline>
            <source src="tools/WhatsApp Video 2026-01-03 at 3.56.12 PM.mp4" type="video/mp4">
        </video>
        <canvas id="pixel-canvas"></canvas>
    </div>

    <div class="container main-content">
        <h1>Smart Class: [1]</h1> <!-- Same as title -->

        <!-- Custom Content Starts Here -->
        <p>[Intro paragraph: Add your text here. E.g., A smart class is an educational environment that integrates technology to enhance teaching and learning.]</p>

        <h2>Key Points</h2>
        <ul>
            <li>[Point 1: E.g., Interactive whiteboards for real-time collaboration.]</li>
            <li>[Point 2: E.g., Digital resources accessible via devices.]</li>
            <li>[Point 3: Add more as needed.]</li>
        </ul>

        <!-- Optional: Add an image (host image online first, e.g., on imgur.com, and paste URL) -->
        <img src="[Image URL, e.g., https://example.com/smart-class-image.jpg]" alt="Smart Class Illustration">

        <!-- Add more sections if needed, e.g., <h2>Subtopic</h2> <p>Details...</p> -->
        <!-- Custom Content Ends Here -->

        <footer>Presented by [Your Name] | [Date]</footer>
    </div>

    <script>
        const videoContainer = document.getElementById('video-intro-container');
        const video = document.getElementById('intro-video');
        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const mainContent = document.querySelector('.main-content');

        let videoLoaded = false;
        let pixelSize = 10;
        let revealProgress = 0;
        let hideProgress = 0;
        let animationState = 'revealing'; // revealing, playing, paused, waiting, hiding, done
        let waitStartTime = 0;
        let hasResumed = false;

        // Load video metadata
        video.addEventListener('loadedmetadata', () => {
            const aspectRatio = video.videoWidth / video.videoHeight;
            const maxWidth = window.innerWidth * 0.9;
            const maxHeight = window.innerHeight * 0.9;
            
            let displayWidth = maxWidth;
            let displayHeight = maxWidth / aspectRatio;
            
            if (displayHeight > maxHeight) {
                displayHeight = maxHeight;
                displayWidth = maxHeight * aspectRatio;
            }
            
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            video.style.width = displayWidth + 'px';
            video.style.height = displayHeight + 'px';
            
            videoLoaded = true;
        });

        // Wait for first frame to load, then start reveal animation
        video.addEventListener('loadeddata', () => {
            // Seek to first frame and pause
            video.currentTime = 0;
            requestAnimationFrame(animate);
        });

        // Pixel glitter reveal effect
        function drawPixelReveal() {
            if (!videoLoaded) return;
            
            // Start with black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create temporary canvas for video frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            
            // Draw current video frame (even if paused)
            tempCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const revealHeight = canvas.height * revealProgress;
            
            // Draw pixels with glitter effect
            for (let y = 0; y < canvas.height; y += pixelSize) {
                for (let x = 0; x < canvas.width; x += pixelSize) {
                    const pixelY = y + pixelSize / 2;
                    
                    if (pixelY <= revealHeight) {
                        // Add randomness for glitter effect
                        const glitterOffset = Math.random() * 2;
                        const alpha = 0.8 + Math.random() * 0.2;
                        
                        const imageData = tempCtx.getImageData(x, y, pixelSize, pixelSize);
                        const avgColor = getAverageColor(imageData);
                        
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = `rgb(${avgColor.r}, ${avgColor.g}, ${avgColor.b})`;
                        ctx.fillRect(
                            x + Math.random() * glitterOffset, 
                            y + Math.random() * glitterOffset, 
                            pixelSize - glitterOffset, 
                            pixelSize - glitterOffset
                        );
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }

        // Pixel glitter hide effect (reverse)
        function drawPixelHide() {
            if (!videoLoaded) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Create temporary canvas for video frame
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const hideHeight = canvas.height * (1 - hideProgress);
            
            // Draw pixels with glitter effect (hiding from bottom to top)
            for (let y = 0; y < canvas.height; y += pixelSize) {
                for (let x = 0; x < canvas.width; x += pixelSize) {
                    const pixelY = y + pixelSize / 2;
                    
                    if (pixelY <= hideHeight) {
                        const glitterOffset = Math.random() * 2;
                        const alpha = 0.8 + Math.random() * 0.2;
                        
                        const imageData = tempCtx.getImageData(x, y, pixelSize, pixelSize);
                        const avgColor = getAverageColor(imageData);
                        
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = `rgb(${avgColor.r}, ${avgColor.g}, ${avgColor.b})`;
                        ctx.fillRect(
                            x + Math.random() * glitterOffset, 
                            y + Math.random() * glitterOffset, 
                            pixelSize - glitterOffset, 
                            pixelSize - glitterOffset
                        );
                        ctx.globalAlpha = 1;
                    }
                }
            }
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, hideHeight, canvas.width, canvas.height - hideHeight);
        }

        function getAverageColor(imageData) {
            let r = 0, g = 0, b = 0;
            const pixels = imageData.data.length / 4;
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                r += imageData.data[i];
                g += imageData.data[i + 1];
                b += imageData.data[i + 2];
            }
            
            return {
                r: Math.floor(r / pixels),
                g: Math.floor(g / pixels),
                b: Math.floor(b / pixels)
            };
        }

        function animate() {
            if (animationState === 'revealing') {
                revealProgress += 0.008; // Slower reveal speed
                drawPixelReveal();
                
                if (revealProgress >= 1) {
                    revealProgress = 1;
                    animationState = 'playing';
                    // Start playing video after reveal is complete
                    video.play();
                }
                requestAnimationFrame(animate);
            } 
            else if (animationState === 'playing') {
                // Keep drawing video while it plays
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Pause at 3 seconds
                if (video.currentTime >= 3 && !hasResumed) {
                    video.pause();
                    animationState = 'paused';
                    waitStartTime = Date.now();
                }
                
                // Check if video has ended (after resume)
                if (video.ended || (hasResumed && video.currentTime >= video.duration - 0.1)) {
                    animationState = 'hiding';
                }
                requestAnimationFrame(animate);
            }
            else if (animationState === 'paused') {
                // Keep showing paused frame for 5 seconds
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const elapsedTime = Date.now() - waitStartTime;
                if (elapsedTime >= 3000) {
                    hasResumed = true;
                    video.play();
                    animationState = 'playing';
                }
                requestAnimationFrame(animate);
            }
            else if (animationState === 'hiding') {
                hideProgress += 0.01; // Slower hide speed
                drawPixelHide();
                
                if (hideProgress >= 1) {
                    animationState = 'done';
                    videoContainer.style.display = 'none';
                    mainContent.classList.add('visible');
                } else {
                    requestAnimationFrame(animate);
                }
            }
        }

        // Handle video end
        video.addEventListener('ended', () => {
            if (animationState === 'playing' && hasResumed) {
                animationState = 'hiding';
                requestAnimationFrame(animate);
            }
        });

        // Start loading video
        video.load();
    </script>
</body>
</html>